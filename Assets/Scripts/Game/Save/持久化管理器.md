# 轻量量分段式存档系统使用说明 (Updated)

> 版本：含异步保存、脏标记(IDirtySaveSectionProvider)、可视化编辑器 (SaveEditorWindow)、可扩展接口（序列化 / 加密 / 哈希）、多存档槽位支持  
> 适用：独立 2D 游戏快速迭代，从简开始，可平滑升级。

---

## 目录
1. 系统概览
2. 关键结构与职责
3. 快速上手步骤
4. SaveSystemConfig 配置字段详解
5. 保存生命周期与调用时机
6. 分段 Provider 编写指南 (含脏标记)
7. 自定义 Key / 类型：ICustomSaveSectionKey / IExposeSectionType
8. 脏标记 (IDirtySaveSectionProvider) 工作流
9. 同步 vs 异步保存 (ManualSave / ManualSaveAsync)
10. 可视化编辑器 SaveEditorWindow
11. 不可直接序列化数据的处理策略（替身 / ID 映射）
12. 加密 / 哈希 / 备份机制
13. 错误处理 & 调试技巧
14. 版本演进与迁移思路
15. 性能建议
16. 常见问题 FAQ
17. 示例代码片段集锦
18. 下一步扩展建议

---

## 1. 系统概览

| 目标 | 实现 |
|------|------|
| 模块化 | 每个系统通过 ISaveSectionProvider 提供自己的 Section |
| 最小依赖 | 默认使用 UnityJsonSerializer (JsonUtility) |
| 可进化 | 接口: ISaveSerializer / ISaveEncryptor / IHashProvider |
| 分段存档 | SaveRootData.sections = List<SectionBlob> |
| 高迭代 | Raw JSON & 表单可视化编辑器 |
| 性能可控 | 脏标记 + 异步保存 |
| 安全/完整性 | 可选 SHA256 校验与备份文件 |
| 扩展空间 | 多槽位 / 压缩 / 迁移 / 云同步 已支持多槽位 |

---

## 2. 关键结构与职责

| 类型 | 描述 |
|------|------|
| SaveManager | 运行时总控：注册 Provider，加载 / 恢复 / 保存（同步+异步），管理多存档槽位 |
| SaveSystemConfig | ScriptableObject 配置参数，包含多槽位相关设置 |
| ISaveSectionProvider | 模块提供分段快照 (Capture/Restore) |
| IDirtySaveSectionProvider | Provider 可声明自己是否有变动 (Dirty) 以便增量保存 |
| ICustomSaveSectionKey | 覆盖 Section 默认存档键 |
| IExposeSectionType | 显式声明 Section 类型避免反射猜测 |
| SaveRootData | 顶层数据：version / lastSaveUnix / sections |
| SectionBlob | 单个分段：key / type / json |
| SaveService | 纯 I/O：JSON ↔ 字节 ↔ (Encrypt/Hash) ↔ 磁盘，支持多槽位文件操作 |
| UnityJsonSerializer | 默认序列化实现（可替换） |
| NoOpEncryptor / Sha256HashProvider | 默认加密(NoOp) / 哈希(SHA256) |
| SaveEditorWindow | 编辑器工具：查看、增删、修改、写回、推送运行时，支持多槽位切换 |

---

## 3. 快速上手步骤

1. 创建配置：  
   右键 → Create → Game/Save/Save System Config (SaveSystemConfig.asset)

2. 在启动场景的 SingletonManager 配置中加入 SaveManager 预制体，并引用上一步的配置。

3. 为每个逻辑模块实现一个 Provider：
   ```csharp
   public class PlayerProvider : MonoBehaviour, ISaveSectionProvider, IExposeSectionType, ICustomSaveSectionKey {
       [Serializable] public class PlayerSection : ISaveSection {
           public string id;
           public int level;
           public float hp;
       }
       public string Key => "Player";
       public Type SectionType => typeof(PlayerSection);
       public bool Ready => true;

       public ISaveSection Capture()
           => new PlayerSection { id = _id, level = _level, hp = _hp };

       public void Restore(ISaveSection sec) {
           var s = sec as PlayerSection;
           if (s == null) return; // 首次或缺失
           _id = s.id; _level = s.level; _hp = s.hp;
       }

       void OnEnable()=> SaveManager.Instance?.RegisterProvider(this);
       void OnDisable()=> SaveManager.Instance?.UnregisterProvider(this);

       string _id="p1"; int _level=1; float _hp=100;
   }
   ```

4. 运行：
   - 首次无存档 → 如果 `writeImmediatelyAfterFirstLoad=false` 只在第一次保存时生成。
   - 用 `SaveManager.Instance.ManualSave()` / 自动触发保存。
   - 查看 `Application.persistentDataPath` 下的 `slot_0.dat`（默认槽位）。

5. 打开编辑器窗口：Tools → Save System → Save Editor  
   修改 Section → “写回磁盘” → （Play 模式下）“推送到运行时 & Save”。

---

## 4. SaveSystemConfig 配置字段详解

| 分类 | 字段 | 说明 |
|------|------|------|
| 路径 & 文件 | fileName | 存档文件名前缀，多槽位时会自动添加槽位索引，如"save.dat"会变为"slot_0.dat" |
| 路径 & 文件 | useBackup | 是否使用备份文件，备份文件名为"slot_0.dat.bak" |
| 序列化 | prettyJson | 是否格式化JSON，便于阅读 |
| 序列化 | storeTypeAssemblyQualified | 类型名称是否包含程序集信息，false仅使用FullName |
| 加密 / 哈希 | enableEncryption | 是否启用加密 |
| 加密 / 哈希 | enableHash | 是否启用哈希校验 |
| 加密 / 哈希 | useSha256 | 是否使用SHA256哈希，false则不使用哈希 |
| 加密 / 哈希 | encryptionKey | 加密密钥，后续实现AES时使用 |
| 自动保存 | saveOnQuit | 退出时是否自动保存 |
| 自动保存 | saveOnPause | 暂停时是否自动保存 |
| 自动保存 | saveOnFocusLost | 失去焦点时是否自动保存 |
| 自动保存 | autoIntervalEnabled | 是否启用定时自动保存 |
| 自动保存 | autoIntervalSeconds | 定时自动保存间隔（秒） |
| 初始化 | loadOnAwake | 是否在Awake时加载存档 |
| 初始化 | restoreAfterSingletonsReady | 是否等单例管理器初始化完成后再恢复数据 |
| 初始化 | autoDiscoverProvidersOnSceneLoad | 场景加载时是否自动发现Provider |
| 初始化 | discoverInactiveGameObjects | 是否发现非激活状态的游戏对象上的Provider |
| Provider 过滤 | excludeTypeNames | 要排除的Provider类型全名列表 |
| Provider 过滤 | explicitIncludeTypeNames | 只包含的Provider类型全名列表，为空则包含所有 |
| 安全 / 完整性 | forbidAutoSaveBeforeFirstRestore | 是否阻止首次恢复前的自动保存 |
| 安全 / 完整性 | allowEmptySnapshot | 是否允许保存空的快照 |
| 安全 / 完整性 | minSectionCountForValidSnapshot | 有效快照的最小Section数量 |
| 安全 / 完整性 | skipIfUnchanged | 内容未变化时是否跳过保存 |
| 调试 | verboseLog | 是否输出详细日志 |
| 调试 | logOnEveryAutoSave | 每次自动保存是否输出日志 |
| 其他 | writeImmediatelyAfterFirstLoad | 首次无存档时是否在创建后立即写入 |
| 多槽位 | maxSlotCount | 最大存档槽位数量 |
| 多槽位 | defaultSlotIndex | 默认使用的存档槽位索引 |

---

## 5. 保存生命周期与调用时机

1. Awake: 可选加载存档 (loadOnAwake)，可指定加载的槽位
2. SceneLoaded: 自动发现 Provider
3. SingletonManager 初始化阶段：调用 SaveManager.Initialize → RestoreToProviders
4. 运行时：
   - ManualSave()：保存到当前槽位
   - ManualSave(int slotIndex)：保存到指定槽位
   - ManualSaveAsync()：异步保存到当前槽位
   - ManualSaveAsync(int slotIndex)：异步保存到指定槽位
   - 自动：间隔 / 暂停 / 失焦 / 退出，保存到当前槽位
5. 切换槽位：调用 SwitchSlot(int slotIndex)，会加载新槽位的存档并恢复
6. RestoreSingleProvider：当一个新的 Provider 在 Restore 之后注册时立即补回数据

---

## 6. 分段 Provider 编写指南

必需实现：
```csharp
public interface ISaveSectionProvider {
    bool Ready { get; }
    ISaveSection Capture();
    void Restore(ISaveSection section);
}
```

最佳实践：
- Ready 在模块需要依赖（如资源表 / 数据库）完成后再返回 true。
- Capture 返回 null 表示“本次不写入”（比如无数据或未初始化）。
- Restore(null) 表示没有历史数据（首次或被删除）→ 设默认值。
- OnEnable / OnDisable 自动注册/注销。
- 若需要支持脏标记，实现 IDirtySaveSectionProvider 接口。
- 若需要自定义 Section 键，实现 ICustomSaveSectionKey 接口。
- 若需要显式声明 Section 类型，实现 IExposeSectionType 接口。

---

## 7. 自定义 Key / 类型：ICustomSaveSectionKey / IExposeSectionType

- ICustomSaveSectionKey：允许 Provider 自定义 Section 的键，默认使用类型名作为键。
  ```csharp
  public interface ICustomSaveSectionKey {
      string Key { get; }
  }
  ```

- IExposeSectionType：显式声明 Section 的类型，避免通过反射猜测类型，提高性能和安全性。
  ```csharp
  public interface IExposeSectionType {
      Type SectionType { get; }
  }
  ```

示例：
```csharp
public class PlayerProvider : MonoBehaviour, ISaveSectionProvider, ICustomSaveSectionKey, IExposeSectionType {
    public string Key => "PlayerData";
    public Type SectionType => typeof(PlayerSection);
    // ... 其他实现
}
```

---

## 8. 脏标记 (IDirtySaveSectionProvider) 工作流

1. 实现 IDirtySaveSectionProvider 接口：
   ```csharp
   public interface IDirtySaveSectionProvider : ISaveSectionProvider {
       bool IsDirty { get; }
       void ClearDirty();
   }
   ```

2. 工作流程：
   - 当数据发生变化时，将 IsDirty 设为 true。
   - 调用 ManualSaveAsync(forceAll: false) 时，只会保存 IsDirty 为 true 的 Section。
   - 保存完成后，框架会自动调用 ClearDirty() 重置脏标记。

3. 最佳实践：
   - 在 Setter 中设置脏标记，或在批量修改后手动设置。
   - 复杂对象可实现深度脏标记检查。

示例：
```csharp
public class InventoryProvider : MonoBehaviour, IDirtySaveSectionProvider {
    private bool _isDirty;
    public bool IsDirty => _isDirty;
    
    private List<Item> _items = new List<Item>();
    
    public void AddItem(Item item) {
        _items.Add(item);
        _isDirty = true;
    }
    
    public void ClearDirty() {
        _isDirty = false;
    }
    
    // ... 其他实现
}
```

---

## 9. 同步 vs 异步保存

| 方法 | 描述 | 适用 |
|------|------|------|
| ManualSave() | 主线程整合并立即写文件到当前槽位 | 小型存档，简单操作 |
| ManualSave(int slotIndex) | 主线程整合并立即写文件到指定槽位 | 需要指定槽位的同步保存 |
| ManualSaveAsync(forceAll, ct) | 线程池处理序列化 + 写入当前槽位，支持脏过滤 | 大型/频繁保存情景 |
| ManualSaveAsync(int slotIndex, forceAll, ct) | 线程池处理序列化 + 写入指定槽位，支持脏过滤 | 需要指定槽位的异步保存 |

注意：
- 异步保存有重入保护（正在保存时再次调用会跳过）。
- 异步保存不阻塞主线程；需要 UI 提示可自定义事件。
- 切换槽位时，确保当前没有正在进行的保存操作。

---

## 10. 可视化编辑器 SaveEditorWindow

菜单：`Tools / Save System / Save Editor`  
功能：
- 读取磁盘存档（支持多槽位切换）（HASH: / DATA: Base64）
- 列出所有 Section (key/type/size/状态标签)
- Raw JSON & 表单模式编辑
- 新增 / 复制 / 删除 / 撤销
- 写回磁盘 / 推送运行时（Play 模式自动调用 SaveManager.ManualLoad + ManualSave）
- 类型扫描 / 搜索
- Dirty 标记自动提示
- 槽位管理：新建、删除、复制槽位内容

建议：
- Play 下修改后使用“推送到运行时 & Save”避免游戏逻辑覆盖。
- 切换槽位前确保已保存当前槽位的修改。

---

## 11. 不可直接序列化数据的处理策略（替身 / ID 映射）

对于无法直接序列化的数据（如 UnityEngine.Object 引用、 delegates 等），采用以下策略：

1. 替身模式（Surrogate）：
   - 创建可序列化的替身类，包含重建原始对象所需的所有信息。
   - 在 Capture 时将原始对象转换为替身对象。
   - 在 Restore 时将替身对象重建为原始对象。

2. ID 映射：
   - 为资源、对象等分配唯一 ID。
   - 序列化时只保存 ID。
   - 恢复时通过 ID 从注册表中查找对应的对象。

示例：
```csharp
// 不可序列化的原始类
public class Weapon {
    public GameObject Prefab; // 无法直接序列化
    public int Damage;
}

// 替身类
[Serializable]
public class WeaponSurrogate : ISaveSection {
    public string PrefabId; // 资源ID
    public int Damage;
}

// Provider 中的转换
public ISaveSection Capture() {
    return new WeaponSurrogate {
        PrefabId = ResourceRegistry.GetId(weapon.Prefab),
        Damage = weapon.Damage
    };
}

public void Restore(ISaveSection section) {
    var surrogate = section as WeaponSurrogate;
    if (surrogate == null) return;
    
    weapon = new Weapon {
        Prefab = ResourceRegistry.GetObject(surrogate.PrefabId),
        Damage = surrogate.Damage
    };
}
```

---

## 12. 加密 / 哈希 / 备份机制

1. 加密：
   - 默认使用 NoOpEncryptor（不加密）。
   - 可实现 ISaveEncryptor 接口自定义加密算法（如 AES）。
   - 在 SaveSystemConfig 中启用加密并设置密钥。

2. 哈希：
   - 默认支持 SHA256 哈希校验。
   - 在 SaveSystemConfig 中启用哈希（enableHash = true, useSha256 = true）。
   - 加载时会验证哈希值，不匹配则视为文件损坏。

3. 备份：
   - 启用 useBackup 后，每次保存会生成 .bak 文件。
   - 文件损坏时，可尝试从备份文件恢复。
   - 多槽位时，每个槽位都有对应的备份文件。

---

## 13. 错误处理 & 调试技巧

| 情况 | 日志 | 解决 |
|------|------|------|
| Hash mismatch | “[SaveService] Hash mismatch” | 文件损坏 / 外部修改 → 尝试从对应槽位的 .bak 文件恢复 |
| 反序列化失败 | “反序列化 Section 失败” | JSON 字段丢失/改名 → 手动迁移或恢复 |
| 类型不匹配 | “Section 类型不一致” | 类重命名 → 临时保留旧类 / 编写迁移脚本 |
| Provider 未 Restore | Ready=false 在延迟阶段 → 等依赖加载后调用 DevForceRestore() |
| 槽位不存在 | “Slot index out of range” | 检查槽位索引是否在有效范围内（0 到 maxSlotCount-1） |
| 保存冲突 | “Save in progress, skipping” | 避免短时间内频繁调用保存，可等待前一次保存完成 |

调试技巧：
- 开启 verboseLog 查看详细的保存/加载过程。
- 使用 SaveEditorWindow 检查存档内容是否正确。
- 保存失败时，检查 Application.persistentDataPath 目录的读写权限。
- 多槽位问题可查看每个槽位的文件大小和修改时间，判断是否正确写入。

---

## 14. 版本演进与迁移思路

当前 SaveRootData.version = 1  
升级步骤：
1. 增加字段 → 默认值即可
2. 删除字段 → 旧 json 中多余字段被忽略
3. 重命名字段 / 类型 → 在加载后手动扫描 SectionBlob.json (字符串替换 / 解析旧结构再重组)
4. 扩展：实现 MigrationPipeline，在 SaveManager.InternalLoad 后先对 _composite.sections 做迁移再 Restore
5. 多槽位迁移：可编写工具批量迁移旧存档到多槽位格式

迁移示例：
```csharp
public class MigrationPipeline {
    public void Migrate(SaveRootData data, int fromVersion) {
        if (fromVersion < 2) {
            MigrateToVersion2(data);
        }
        // 后续版本迁移...
    }
    
    private void MigrateToVersion2(SaveRootData data) {
        // 版本 2 的迁移逻辑
        foreach (var section in data.sections) {
            if (section.key == "OldKey") {
                section.key = "NewKey";
                // 其他字段迁移...
            }
        }
        data.version = 2;
    }
}
```

---

## 15. 性能建议

| 需求 | 建议 |
|------|------|
| 频繁小改动保存 | 使用 IDirtySaveSectionProvider + ManualSaveAsync |
| 大量 Section | Key 简短化，避免过长类型名（选择 FullName 替代 AssemblyQualifiedName） |
| 序列化开销 | 避免在 Capture() 内做重量级计算；缓存数据结构 |
| 降低 GC | 避免在 Capture() 临时分配大 List（复用对象） |
| 更快序列化 | 后期切换到更高性能库 (MessagePack / MemoryPack) 保留接口不变 |
| 多槽位管理 | 预加载常用槽位信息，避免频繁读取磁盘 |
| 大型存档 | 实现 ICompressionProvider 压缩存档数据，减少磁盘占用和读写时间 |

---

## 16. 常见问题 FAQ

**Q: 为何新 Provider 在运行时没有恢复数据？**  
A: 可能在 Restore 之后才注册；框架调用 RestoreSingleProvider；若类型或 Key 改动导致找不到匹配 Section。

**Q: 文件显示 HASH 不匹配但 .bak 也坏了？**  
A: 玩家手动修改 / 未完整写入；可回退到默认存档或忽略哈希继续读（修改代码调试）。

**Q: 表单模式下某 Section 显示错误？**  
A: JSON 不合法或字段无法解析（改回 Raw JSON 修复）。

**Q: 能否只保存某几个 Provider？**  
A: 使用脏标记并调用 ManualSaveAsync(forceAll:false)。

**Q: 加密后 SaveEditorWindow 显示乱码？**  
A: 需要在编辑器工具里引入同样的解密逻辑（当前示例未启用加密）。

**Q: 如何切换存档槽位？**  
A: 调用 SaveManager.Instance.SwitchSlot(int slotIndex) 方法，会自动加载该槽位的存档并恢复数据。

**Q: 最大支持多少个存档槽位？**  
A: 由 SaveSystemConfig 中的 maxSlotCount 配置，默认为 5 个，可根据需要调整。

**Q: 如何复制一个槽位的内容到另一个槽位？**  
A: 在 SaveEditorWindow 中选择源槽位，点击"复制到"，然后选择目标槽位。

---

## 17. 示例代码片段集锦

### 17.1 切换存档槽位
```csharp
// 切换到第 2 个槽位（索引从 0 开始）
public void SwitchToSlot2() {
    if (SaveManager.Instance.CanSwitchSlot(2)) {
        SaveManager.Instance.SwitchSlot(2);
        Debug.Log("已切换到槽位 2");
    } else {
        Debug.LogError("无法切换到槽位 2");
    }
}
```

### 17.2 异步保存到指定槽位
```csharp
// 保存所有脏 Section 到槽位 1，界面提示
async void SaveToSlot1IfDirty() {
    await SaveManager.Instance.ManualSaveAsync(1, forceAll: false);
    // 显示保存完成提示
}
```

### 17.3 在编辑器窗口写回后强制运行时刷新
```csharp
// SaveEditorWindow 中调用
SaveManager.Instance.ManualLoad(true); // 重新加载 + Restore
SaveManager.Instance.ManualSave();     // 立即写入 (保证一致)
```

### 17.4 创建新存档槽位
```csharp
public void CreateNewGame(int slotIndex) {
    if (SaveManager.Instance.CanSwitchSlot(slotIndex)) {
        // 重置所有游戏数据
        GameResetManager.ResetAllData();
        // 切换到指定槽位并保存
        SaveManager.Instance.SwitchSlot(slotIndex);
        SaveManager.Instance.ManualSave();
    }
}
```

---

## 18. 下一步扩展建议

| 方向 | 说明 |
|------|------|
| 云同步 | 集成云存储服务（如 Google Drive, iCloud）实现存档云同步 |
| 压缩支持 | Encrypt 前增加 ICompressionProvider (LZ4 / GZip) |
| 迁移系统 | 定义 IMigrationStep + MigrationRunner 支持复杂结构变更 |
| 事件广播 | SaveManager 增加 OnBeforeSave / OnAfterRestore / OnSlotSwitched 等事件 |
| 断点调试友好 | 抽离文件读写接口以便单元测试 |
| 热更兼容 | Section 数量与类型动态注册/剔除 |
| 存档缩略图 | 为每个槽位添加预览图，在选择界面显示 |
| 自动备份管理 | 定期自动备份，限制备份数量，避免占用过多空间 |

---

## 总结

你拥有一个：
- 分段化
- 低耦合
- 支持脏增量与异步
- 内置可视化编辑的
- 支持多存档槽位
- 可渐进扩展加密 / 迁移 / 压缩
  的存档系统。

保持 Section 纯数据化 + Provider 负责运行时映射，可最小化未来架构变化的迁移成本。

需要更多示例（AES 加密 / 云同步 / 压缩实现）继续提出即可。祝开发顺利！