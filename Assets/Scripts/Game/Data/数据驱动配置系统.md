# 数据驱动配置系统 使用说明 (GameRuntimeData + DefinitionSectionBase)

版本: 1.0  
最后更新: 2025-09-03  
作者: 郑钦

---

## 目录
1. 系统目标概述
2. 核心概念
3. 目录 & 主要文件角色
4. 初始化执行流程
5. 如何新增一个配置 Section
6. 如何访问配置与定义
7. 编辑器工作流（配合 [CustomConfig] 与 ConfigDatabaseWindow）
8. 运行时 / 构建注意事项
9. 校验与调试
10. 常见错误与诊断
11. 性能与扩展建议
12. 设计 FAQ
13. 典型使用示例代码
14. 未来可扩展方向

---

## 1. 系统目标概述

该系统提供一套“**纯数据驱动 / 无硬编码字段 / 自动扫描加载 / 泛型注册表**”的游戏配置框架，解决以下痛点：

| 需求 | 解决方式 |
| ---- | -------- |
| 避免 GameContext 硬编码 Items/Recipes 等字段 | 使用 GameRuntimeData 动态注册表 + Type/SectionName/DefinitionType 3 重索引 |
| 快速新增任意配置集合（Section） | 继承 DefinitionSectionBase<TDef> 并实现 Definition（ID） |
| 统一访问方式 | GameContext.Instance.GetDefinition<TDef>(id) |
| 编辑器集中管理与批量操作 | 使用 [CustomConfig] + ConfigDatabaseWindow |
| 安全检验/调试 | SectionValidationUtility 与日志输出 |
| 后期扩展（排序、代码生成、跨 Section 依赖校验） | 已预留结构 |

---

## 2. 核心概念

| 名称 | 含义 |
| ---- | ---- |
| IDefinition | 需要有唯一 int Id 的最小定义条目接口 |
| DefinitionRegistry<TDef> | 泛型注册表：Id → 定义对象（可继承扩展） |
| DefinitionSectionBase<TDef> | 泛型 Section 基类：持有 List<TDef>，Build 时创建 Registry 并注册 |
| IContextSection | GameContext 可识别、会在初始化中 Build 的 Section 接口 |
| GameRuntimeData | 统一容器：Type → Instance / SectionName → Instance / DefinitionType → IDefinitionRegistry |
| RuntimeConfigLoader | 反射扫描 + 资产加载 |
| GameContext | 由 SingletonManager 驱动，负责一次性构建所有 Section |
| [CustomConfig] | 仅用于编辑器 ConfigDatabaseWindow 的“显示过滤”标记 |
| ConfigDatabaseWindow | 统一管理 ScriptableObject 的编辑器工具（已在项目中） |

---

## 3. 目录 & 主要文件角色

```
Scripts/
  Data/Core/
    IDefinition.cs
    IDefinitionRegistry.cs
    DefinitionRegistry.cs
    DefinitionSectionBase.cs
    IContext.cs
    IContextSection.cs
    GameRuntimeData.cs
    GameContextConfig.cs
    RuntimeConfigLoader.cs
    SectionValidationUtility.cs (Editor)
  Data/Items/
    ItemsSection.cs (示例)
  Data/Recipes/
    RecipesSection.cs (示例)
  ...
  Core/
    GameContext.cs
```

---

## 4. 初始化执行流程

```
+---------------------------+
| SingletonManager          |
|  (Initialize Pipeline)    |
+-------------+-------------+
              |
              v
      GameContext.Initialize()
              |
              v
   RuntimeConfigLoader.GetSectionTypes()
              |
      反射所有实现 IContextSection
              |
              v
   每种 SectionType -> 查找所有资产实例
              |
              v
      逐个调用 s.Build(GameRuntimeData)
              |
              v
  GameRuntimeData.RegisterSection(sectionName, registry)
    ├─ 保存 SectionName → 实例
    ├─ 保存 实例类型(Type) → 实例
    └─ 若是 IDefinitionRegistry → 保存 DefinitionType → Registry
              |
              v
        （可选）Data.LogSummary()
              |
              v
        对外提供访问 API
```

ASCII 总览图：

```
[ScriptableObject Assets]
   | ItemsSection.asset
   | RecipesSection.asset
   | MachinesSection.asset
            |
            v (Build)
+-----------------------------+
|        GameRuntimeData      |
|  - _typeMap (Type→Inst)     |
|  - _sectionMap (string→Inst)|
|  - _definitionRegs (T→Reg)  |
+-----------------------------+
            ^
            |
      GameContext
```

---

## 5. 如何新增一个配置 Section

步骤：
1. 创建定义类型：
   ```csharp
   [System.Serializable]
   public class EnemyDefinition : IDefinition {
       [SerializeField] private int id;
       public int Id => id;
       public string displayName;
       public int hp;
       public int attack;
   }
   ```
2. 创建 Section 资产脚本：
   ```csharp
   [CustomConfig] // 让编辑器窗口识别（可选）
   [CreateAssetMenu(menuName="Game/Config/Enemies Section")]
   public class EnemiesSection : DefinitionSectionBase<EnemyDefinition>
   {
       public override string SectionName => "Enemies"; // 可自定义
       // 如需自定义 Registry，可 override CreateRegistry()
   }
   ```
3. 在项目中右键创建 Enemies Section 资产（建议放 Resources/Config/ 或任意目录）。
4. 在资产 Inspector 中填充 definitions 列表。
5. 运行游戏：控制台输出构建日志（若启用 verbose）。

可选：自定义 Registry
```csharp
public class EnemyRegistry : DefinitionRegistry<EnemyDefinition> {
    public EnemyRegistry(IEnumerable<EnemyDefinition> defs) : base(defs) {}
    public IEnumerable<EnemyDefinition> EnumerateByHP(int min) {
        foreach (var d in Map.Values) if (d.hp >= min) yield return d;
    }
}
public class EnemiesSection : DefinitionSectionBase<EnemyDefinition> {
    protected override IDefinitionRegistry CreateRegistry()
        => new EnemyRegistry(definitions);
}
```

---

## 6. 如何访问配置与定义

通用 API（在任何运行时脚本中）：

```csharp
// 访问定义
var wood = GameContext.Instance.GetDefinition<ItemDefinition>(1);

// 安全尝试
if (GameContext.Instance.TryGetDefinition<RecipeDefinition>(102, out var recipe)) {
    // 使用 recipe
}

// 获取注册表实例（已知具体类型）
var itemRegistry = GameContext.Instance.GetRegistry<ItemRegistry>();
var plank = itemRegistry.Get(3);

// 按 Section Name 获取（如果你需要）
var enemiesSectionObj = GameContext.Instance.Data.GetBySection("Enemies");
// 根据实际类型再转换
```

错误时抛出的异常：
- GetDefinition<T>(id) 未找到会抛 KeyNotFoundException
- GetRegistry<T>() 未找到类型会抛 InvalidOperationException  
  建议在调试阶段使用 Get*，正式流程中对可选资源使用 Try*。

---

## 7. 编辑器工作流

1. 任何想在 ConfigDatabaseWindow 中集中管理的 ScriptableObject，加上 `[CustomConfig]`。
2. 使用菜单（假设已有）：Tools/Config DB/Config Database 打开窗口。
3. 在左侧类型列表选中 Section 类型，右侧可以：
    - 创建新资产
    - 批量操作（复制 / 删除 / 移动 / 导出 JSON / 重命名）
4. Section 的 definitions 列表即实际数据内容（List<TDef>）。
5. 你可建立多个同类型 Section 资产（多个 ItemsSection），都会被加载并 Build（如果你逻辑允许这样叠加，需要你在自定义 Registry 内决定是否合并/覆盖）。

建议：**一个资源类型一个 Section**，避免多个 Section 合并时出现重复 Id 难界定。

---

## 8. 运行时 / 构建注意事项

| 情况 | 说明 |
| ---- | ---- |
| Editor 模式 | 使用 AssetDatabase.FindAssets 精确定位所有 Section 资产 |
| Player（构建） | 当前实现：Resources.LoadAll("Config", sectionType)；若资产不在 Resources/Config/ 下将无法加载 |
| 多个 Section 同类型 | Build 顺序未定义（取决于 FindAssets / LoadAll 返回）；若有 Id 冲突会在各 Registry 内打印错误 |
| 反射开销 | 初始化时一次性扫描 Assemblies，可通过 GameContextConfig.forceRescanOnPlay 控制是否重复扫描 |
| 代码剥离 | 若使用 IL2CPP 且启用代码裁剪，务必保证 Section 具体类型引用不被裁剪（目前由于继承与实例引用，正常情况下安全） |

---

## 9. 校验与调试

1. 运行菜单：Tools/Config DB/Validate All Sections
    - 将对每个 Section 资产调用一次 Build() 到临时 GameRuntimeData，捕获异常。
2. 在 GameContextConfig 勾选 verbose = true
    - 打印：发现 Section 类型数 / 每类资产数量 / 构建耗时。
3. 调用 Data.LogSummary()（默认启用）
    - 输出注册表与 Section 计数。
4. 自行扩展：
    - 添加 Cross Section Validator（例如校验 RecipeDefinition 引用的 itemId 是否存在）。

示例（跨 Section 校验，可后续添加）：
```csharp
public static class CrossSectionValidator {
    public static void Validate(GameRuntimeData data) {
        if (!data.TryGetDefinition<ItemDefinition>(1, out _)) { /* ... */ }
    }
}
```

在 GameContext.BuildAll() 末尾调用：
```csharp
CrossSectionValidator.Validate(Data);
```

---

## 10. 常见错误与诊断

| 现象 | 原因 | 解决 |
| ---- | ---- | ---- |
| GetDefinition 抛异常 | Id 不存在或 Section 未加载 | 检查资产是否在正确目录；是否正确填 Id；用 TryGetDefinition 预防 |
| Section 没有被构建 | 没有实现 IContextSection | 确认继承 DefinitionSectionBase 或手写实现接口 |
| 运行时不加载某 Section | 构建环境（Player）时未放入 Resources/Config | 移动资产或改加载逻辑为 Addressables |
| 重复 Id 报错 | 定义列表内有重复 Id | 在编辑器窗口内过滤/排序检查，或写校验工具 |
| 构建后访问为 null | 初始化顺序不对 / GameContext 未放入 SingletonManagerConfig | 确认 SingletonManager 初始化完成后再访问 |
| 需要热更 | 当前使用 ScriptableObject + Resources，需要自定义加载管线 | 封装 ISectionAssetProvider 替换 Resources 查找 |

---

## 11. 性能与扩展建议

| 场景 | 优化策略 |
| ---- | -------- |
| Section 数量大 | 代码生成静态 SectionType 列表，跳过反射 |
| 运行时频繁访问定义 | 保持 registry.Get(id) O(1)；若需分类查询，建二级缓存 |
| 需要卸载/重载 | 给 GameRuntimeData 增加 Clear() + 重新 Build；小心引用悬挂 |
| Addressables | 替换 RuntimeConfigLoader 的加载阶段，用标签“ConfigSection”批量加载 |
| 大数据（10000+ 定义） | 考虑二进制数据文件 + 自行反序列化到 struct 或 Blob，保留轻量对象层用于编辑 |

---

## 12. 设计 FAQ

Q: 为什么不用单个“大总表”ScriptableObject？  
A: 拆 Section 便于模块隔离 / 分工 / Addressables 分片加载 / 编辑器分类管理。

Q: 可以让配方直接引用 ItemDefinition 对象而不是 Id 吗？  
A: 可以，但会增加交叉引用 / 序列化依赖链，不利于外部导表与热更。Id 更适合“数据导入→运行时关联”。

Q: 我想控制 Section Build 顺序怎么办？  
A: 新增接口：
```csharp
public interface IOrderedSection { int Order { get; } }
```
扫描后：
```csharp
sectionTypes = sectionTypes.OrderBy(t => (t.GetInterface(nameof(IOrderedSection))!=null ? ((IOrderedSection)asset).Order : 0));
```
或在 Build 前构建元信息列表。

Q: 多个 ItemsSection 合并想报错阻断？  
A: 在 DefinitionSectionBase.Build 前检测 Data 是否已经有同类型 DefinitionType 注册，若不允许则抛异常。

---

## 13. 典型使用示例代码

### 13.1 获取配方并消费材料
```csharp
using Game.Core;
using Game.Data.Recipes;
using Game.Data.Items;

public class CraftExample
{
    public bool TryCraft(int recipeId, PlayerInventory inv)
    {
        if (!GameContext.Instance.TryGetDefinition<RecipeDefinition>(recipeId, out var recipe))
            return false;

        // 校验材料
        foreach (var input in recipe.inputs)
        {
            if (!inv.HasItem(input.itemId, input.count))
                return false;
        }

        // 扣除
        foreach (var input in recipe.inputs)
            inv.RemoveItem(input.itemId, input.count);

        // 产出
        foreach (var output in recipe.outputs)
            inv.AddItem(output.itemId, output.count);

        return true;
    }
}
```

### 13.2 遍历所有 ItemDefinition
```csharp
var reg = GameContext.Instance.GetRegistry<ItemRegistry>();
foreach (var kv in reg.Map)
{
    var def = kv.Value;
    UnityEngine.Debug.Log($"{def.Id} -> {def.displayName}");
}
```

### 13.3 运行时动态查询 Section
```csharp
var data = GameContext.Instance.Data;
foreach (var (name, inst) in data.EnumerateSections())
{
    UnityEngine.Debug.Log($"Section={name}, Type={inst.GetType().Name}");
}
```

### 13.4 自定义校验（在 GameContext.BuildAll() 后）
```csharp
public static class CrossValidator
{
    public static void Validate(GameRuntimeData data)
    {
        // 示例：验证所有 RecipeDefinition 的输入/输出 itemId 合法
        foreach (var t in data.EnumerateDefinitionTypes())
        {
            // 只对 RecipeDefinition 做（示意）
            if (t.Name != "RecipeDefinition") continue;
        }
    }
}
```

---

## 14. 未来可扩展方向

| 方向 | 说明 |
| ---- | ---- |
| Section 初始化优先级 | IOrderedSection + 排序 |
| 代码生成 | 生成 static class ConfigRefs { public const int Item_Wood = 1; ... } |
| 增量热更新 | 自定义 JSON / 二进制导入器 → 运行时替换 registry |
| 依赖图可视化 | 构建后生成 Mermaid 图显示 Section/Definition 关系 |
| 版本兼容 | 在 Definition 增加 version / deprecated 标记，加载时迁移 |
| 数据差异对比 | 两份 Section 资产对比输出 diff（用于数值调优） |

---

## 附录：快速 Checklist

| 需求 | 是否完成 |
| ---- | -------- |
| 新建 SectionType (继承 DefinitionSectionBase) |  |
| 添加 definitions 并填写唯一 Id |  |
| 资产加至项目（必要时放 Resources/Config/） |  |
| 运行验证日志无错误 |  |
| 使用 GetDefinition<T>(id) 成功获取 |  |
| 校验工具通过 (Tools/Config DB/Validate...) |  |
|（可选）跨 Section 引用已验证 |  |

---

## 结束语

该系统核心是“轻量泛型 + 明确数据流 + 可扩展”。  
在未验证玩法前，不要过早加入复杂依赖装饰（例如事件触发、热更层、地址可寻址表）。  
当数据规模 > 数千 或 需热更/远程配置 时，再引入：
- 二进制压缩
- 部分 Section 延迟加载
- 代码生成跳过反射

如需：
- “跨 Section 引用校验实现模板”
- “代码生成器初版”  
  请在对话中明示，我会提供下一步脚本。

祝开发顺利！  
