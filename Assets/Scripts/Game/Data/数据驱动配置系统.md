# 数据驱动配置系统 使用说明 (GameRuntimeData + DefinitionSectionBase)

版本: 1.1  
最后更新: 2025-09-03  
作者: 郑钦（更新整理含资源系统建模建议）

相较 1.0 更新摘要：
- 新增：资源物品 vs 采集节点（Gatherable Node）分离的建模指南
- 新增：运行时状态与存档区分章节
- 新增：跨 Section 引用与校验建议示例
- 新增：采集/掉落/生成相关扩展方向
- 补充 FAQ：为什么不要在 Definition 中保存运行时动态值
- 示例代码扩展为“物品定义 + 采集节点定义”组合

---

## 目录
1. 系统目标概述
2. 核心概念
3. 目录 & 主要文件角色
4. 初始化执行流程
5. 如何新增一个配置 Section
6. 如何访问配置与定义
7. 编辑器工作流（配合 [CustomConfig] 与 ConfigDatabaseWindow）
8. 运行时 / 构建注意事项
9. 校验与调试
10. 常见错误与诊断
11. 性能与扩展建议
12. 设计 FAQ
13. 典型使用示例代码
14. 未来可扩展方向
15. 资源与采集节点建模指南（重要新增）
16. 运行时状态 / 存档 与 Definition 的关系
17. 跨 Section 引用与校验策略
18. ID 管理与防冲突策略
19. 变更记录（Changelog）
    附录：快速 Checklist

---

## 1. 系统目标概述

该系统提供一套“**纯数据驱动 / 无硬编码字段 / 自动扫描加载 / 泛型注册表**”的游戏配置框架，解决以下痛点：

| 需求 | 解决方式 |
| ---- | -------- |
| 避免 GameContext 硬编码 Items/Recipes 等字段 | 使用 GameRuntimeData 动态注册表 + Type/SectionName/DefinitionType 三重索引 |
| 快速新增任意配置集合（Section） | 继承 DefinitionSectionBase<TDef> 并实现 IDefinition |
| 统一访问方式 | GameContext.Instance.GetDefinition<TDef>(id) |
| 编辑器集中管理与批量操作 | [CustomConfig] + ConfigDatabaseWindow |
| 安全检验/调试 | SectionValidationUtility + 日志 |
| 可扩展（跨 Section 校验 / 自定义 Registry / 地址化加载） | 结构已预留 |

---

## 2. 核心概念

| 名称 | 含义 |
| ---- | ---- |
| IDefinition | 具有唯一 int Id 的定义条目接口 |
| DefinitionRegistry<TDef> | Id → 定义实例的字典封装，可继承扩展查询 |
| DefinitionSectionBase<TDef> | 泛型 Section 基类：持有 List<TDef>，Build 时生成 Registry |
| IContextSection | GameContext 扫描 & 构建的 Section 单元 |
| GameRuntimeData | 存放所有注册对象：Type / SectionName / DefinitionType 三索引 |
| RuntimeConfigLoader | 反射扫描 Section 类型 + 加载资产 |
| GameContext | 框架入口：集中构建所有 Section |
| [CustomConfig] | 编辑器标记（供 ConfigDatabaseWindow 过滤显示） |
| Registry 扩展 | 可自定义派生类添加索引 / 条件查询 |
| SectionName | 逻辑命名空间（非类型名）允许手动覆盖 |
| DefinitionType | 一个 Registry 服务的定义类型（TDef） |

---

## 3. 目录 & 主要文件角色

```
Scripts/
  Data/Core/
    IDefinition.cs
    IDefinitionRegistry.cs
    DefinitionRegistry.cs
    DefinitionSectionBase.cs
    IContext.cs
    IContextSection.cs
    GameRuntimeData.cs
    GameContextConfig.cs
    RuntimeConfigLoader.cs
    SectionValidationUtility.cs (Editor)
  Data/Items/
    ItemsSection.cs
  Data/Gatherables/
    GatherableNodesSection.cs (示例扩展)
  Data/Recipes/
    RecipesSection.cs
  ...
  Core/
    GameContext.cs
```

---

## 4. 初始化执行流程

```
+---------------------------+
| SingletonManager          |
| (Initialize Pipeline)     |
+-------------+-------------+
              |
              v
      GameContext.Initialize()
              |
              v
   RuntimeConfigLoader.GetSectionTypes()
              |
     反射所有实现 IContextSection
              |
              v
   每个 SectionType → 枚举其所有资产
              |
              v
         s.Build(data)
              |
              v
  GameRuntimeData.RegisterSection()
   ├─ SectionName → 实例
   ├─ InstanceType → 实例
   └─ DefinitionType → Registry (若实现 IDefinitionRegistry)
              |
              v
        日志 & 可选校验
```

---

## 5. 如何新增一个配置 Section

1. 定义数据结构（实现 IDefinition）
2. 新建 Section 派生自 DefinitionSectionBase<TDef>
3. （可选）自定义 Registry：添加额外检索/索引
4. 创建资产、填充 definitions 列表
5. 运行游戏，验证加载日志

示例（精简）：
```csharp
[System.Serializable]
public class EnemyDefinition : IDefinition {
    [SerializeField] private int id;
    public int Id => id;
    public string displayName;
    public int hp;
    public int attack;
}

[CustomConfig]
[CreateAssetMenu(menuName="Game/Config/Enemies Section")]
public class EnemiesSection : DefinitionSectionBase<EnemyDefinition> {
    public override string SectionName => "Enemies";
}
```

---

## 6. 如何访问配置与定义

```csharp
// 直接取定义（未找到抛异常）
var sword = GameContext.Instance.GetDefinition<ItemDefinition>(1001);

// 安全尝试
if (GameContext.Instance.TryGetDefinition<RecipeDefinition>(3005, out var recipe)) {
    // ...
}

// 获取自定义 Registry
var itemReg = GameContext.Instance.GetRegistry<ItemRegistry>();
var plank = itemReg.Get(1002);

// 遍历所有 Section
foreach (var (name, inst) in GameContext.Instance.Data.EnumerateSections()) {
    Debug.Log($"Section={name}, Type={inst.GetType().Name}");
}
```

---

## 7. 编辑器工作流

1. 想在配置窗口出现 → 加 [CustomConfig]
2. Section 资产可多个（是否允许合并由你决定）
3. definitions 列表：直接拖/增/删
4. 运行前可执行 Validate 菜单快速发现结构错误
5. 建议：一个概念域一个 Section，避免重复 Id 管理困难

---

## 8. 运行时 / 构建注意事项

| 项 | 说明 |
|----|-----|
| Editor 加载 | AssetDatabase.FindAssets 精确加载 |
| Player 加载 | Resources.LoadAll("Config", sectionType)（需放 Resources/Config） |
| 顺序不保证 | 多资产同类型之间无顺序保证 |
| 反射扫描缓存 | forceRescanOnPlay=false 时只第一次扫描 |
| IL2CPP 剪裁 | 继承关系 + 资产引用已防裁剪，复杂动态场景可加 link.xml |
| 多个相同 Section | 若造成 Id 冲突，仅打印错误，不中断构建（可自定义改为抛异常） |

---

## 9. 校验与调试

| 工具 | 作用 |
| ---- | ---- |
| Validate All Sections 菜单 | 尝试构建每个 Section，捕获异常 |
| verbose 日志 | 输出类型数量 / 资产数量 / 耗时 |
| Data.LogSummary() | 输出当前注册计数 |
| 自定义 Cross Validator | 进行跨表引用一致性校验 |

---

## 10. 常见错误与诊断

| 现象 | 原因 | 处理 |
| ---- | ---- | ---- |
| GetDefinition 抛异常 | Id 不存在 | 确认资产 & Id，必要时改用 TryGetDefinition |
| Section 未加载 | 未实现 IContextSection 或未放指定目录 | 确认继承/目录 |
| 重复 Id 日志 | 两个资产包含相同 Id | 在编辑器中整理；考虑写 Id 分配工具 |
| 运行时访问 Null | 初始化顺序错误 | 确认在 GameContext.Init 后执行 |
| 想修改 Definition 值 | 不应在运行时直接改模板 | 拷贝到运行时状态对象 |
| 想做热更 | 需替换加载层（Addressables / 外部 JSON） | 封装 Provider |

---

## 11. 性能与扩展建议

| 场景 | 建议 |
| ---- | ---- |
| 定义数量 < 1k | 现实现足够 |
| 1k~10k | 避免重复字符串解析，必要时改用 struct + Blob |
| >10k | 外部二进制表 + 轻量缓存层 |
| 频繁按条件查询 | 在自定义 Registry 里建索引（如 Tag → List<int>） |
| 动态卸载 | 增加 Unregister/Clear API（当前未实现） |
| 分区域加载 | Addressables 标签化 Section；按需加载后手动 Build |

---

## 12. 设计 FAQ

Q: Definition 可以相互直接引用对象吗？  
A: 可以，但建议优先使用 Id 式引用，便于导表/热更与解耦。

Q: 为什么不要在 Definition 里放“当前剩余次数”？  
A: Definition 是模板（静态），运行时状态应放实例对象；否则多个实体共享同一值产生逻辑污染。

Q: 我需要控制 Section 构建顺序怎么办？  
A: 引入 IOrderedSection 接口或创建 SectionMeta 列表排序。

Q: 想阻止多个同类 Section 共存？  
A: 在 Build 时检测 Data.EnumerateSections() 是否已有同名/同类型并抛异常。

Q: 可以把 JSON 动态加载合并进来吗？  
A: 写一个 JsonSection<TDef>：运行时读取外部文件 → 构建 registry → RegisterSection。

---

## 13. 典型使用示例代码

### 13.1 配方消耗
```csharp
public bool TryCraft(int recipeId, PlayerInventory inv)
{
    if (!GameContext.Instance.TryGetDefinition<RecipeDefinition>(recipeId, out var recipe))
        return false;

    foreach (var input in recipe.inputs)
        if (!inv.HasItem(input.itemId, input.count))
            return false;

    foreach (var input in recipe.inputs)
        inv.RemoveItem(input.itemId, input.count);

    foreach (var output in recipe.outputs)
        inv.AddItem(output.itemId, output.count);

    return true;
}
```

### 13.2 遍历所有物品
```csharp
var reg = GameContext.Instance.GetRegistry<ItemRegistry>();
foreach (var kv in reg.Map)
    Debug.Log($"{kv.Key} -> {kv.Value.displayName}");
```

### 13.3 枚举全部 Section
```csharp
foreach (var (name, inst) in GameContext.Instance.Data.EnumerateSections())
    Debug.Log($"Section={name},Type={inst.GetType().Name}");
```

### 13.4 采集节点运行时
```csharp
public class GatherableNodeRuntime : MonoBehaviour {
    public int nodeDefId;
    private int remaining;
    private float respawnAt;

    void Start() {
        var def = GameContext.Instance.GetDefinition<GatherableNodeDefinition>(nodeDefId);
        remaining = def.maxHarvestCycles;
    }

    public void Harvest(Player p) {
        var def = GameContext.Instance.GetDefinition<GatherableNodeDefinition>(nodeDefId);
        if (remaining <= 0) {
            if (def.renewable && Time.time >= respawnAt) {
                remaining = def.maxHarvestCycles;
            } else return;
        }

        remaining--;
        // 掉落逻辑
        foreach (var drop in def.drops)
            if (UnityEngine.Random.value <= drop.chance)
                p.Inventory.AddItem(drop.itemId, UnityEngine.Random.Range(drop.min, drop.max + 1));

        if (remaining <= 0 && def.renewable)
            respawnAt = Time.time + def.respawnSeconds;
    }
}
```

### 13.5 跨表校验示例
```csharp
public static class CrossSectionValidator {
    public static void Validate(GameRuntimeData data) {
        // 例：所有配方引用的 itemId 必须存在
        // （此处伪代码，需遍历 RecipeDefinition registry）
    }
}
```

---

## 14. 未来可扩展方向

| 方向 | 说明 |
| ---- | ---- |
| Section 初始化优先级 | IOrderedSection |
| 代码生成 | 生成静态 Id 常量类 / 枚举 |
| 热更新 | 自定义 Provider + JSON / Bin Patch |
| 差异对比 | 输出旧/新资产差异报告 |
| 数据可视化 | 生成依赖图（Mermaid） |
| 自动索引 | Registry 构建后建立标签→Id 集合 |
| 数据版本迁移 | 增加 version / deprecated 字段 |

---

## 15. 资源与采集节点建模指南（新增重点）

区分三个层次：

| 层次 | 描述 | 是否 Definition | 示例字段 |
|------|------|----------------|---------|
| 物品（Item / Resource Item） | 背包中存在的抽象物品类型 | 是 | id, displayName, icon, maxStack, tags |
| 采集节点模板（Gatherable Node） | 世界中“可采集对象”的行为模版 | 是 | id, displayName, renewable, respawnSeconds, maxHarvestCycles, drops[], biomeWeights[] |
| 节点运行时实例（Node Instance） | 世界上第 N 棵树的当前状态 | 否（运行时） | nodeDefId, remainingCycles, respawnAt, position, seed |

典型拆分：

```csharp
[Serializable]
public class ItemDefinition : IDefinition {
    [SerializeField] private int id;
    public int Id => id;
    public string displayName;
    public Sprite icon;
    public int maxStack = 99;
    public string[] tags;
}

[Serializable]
public class GatherableNodeDefinition : IDefinition {
    [SerializeField] private int id;
    public int Id => id;
    public string displayName;
    public bool renewable = true;
    public int respawnSeconds = 300;
    public int maxHarvestCycles = 3;
    public ResourceDrop[] drops;
    public BiomeSpawnWeight[] spawnWeights;
}

[Serializable]
public struct ResourceDrop {
    public int itemId;
    public int min;
    public int max;
    public float chance; // 0~1
}

[Serializable]
public struct BiomeSpawnWeight {
    public int biomeId;
    public float weight;
}
```

不要把 remainingCycles 等“可变值”放进 Definition，否则多个实例会共享状态。

---

## 16. 运行时状态 / 存档 与 Definition 的关系

| 项 | 存什么 | 如何关联 |
|----|--------|---------|
| 存档（SaveData） | Node 实例数组 / 背包条目 | 保存定义 Id + 运行时字段 |
| 加载时 | 用 Id 重新 GetDefinition | 恢复模板属性 |
| 变更 | 只改运行时对象，不写回 ScriptableObject |

示例存档片段（伪 JSON）：
```json
{
  "nodes":[
    {"nodeDefId":12,"pos":[10,0,5],"remaining":1,"respawnAt":12345.6},
    {"nodeDefId":13,"pos":[15,0,9],"remaining":0,"respawnAt":13000.2}
  ],
  "inventory":[
    {"itemId":1001,"count":34},
    {"itemId":1002,"count":5}
  ]
}
```

---

## 17. 跨 Section 引用与校验策略

| 场景 | 校验方式 |
| ---- | -------- |
| RecipeDefinition 引用 ItemDefinition | 遍历所有 recipes.inputs/outputs -> TryGetDefinition<ItemDefinition> |
| GatherableNodeDefinition 掉落 itemId | 遍历 drops[] |
| BiomeSpawnWeight 引用 biomeId | BiomeDefinition 是否存在 |
| 技能引用 buffId | BuffDefinition 是否存在 |

可实现一个统一校验入口：
```csharp
public interface IConfigValidator {
    void Validate(GameRuntimeData data, List<string> issues);
}
```
然后扫描实现 IConfigValidator 的脚本，集中运行。

---

## 18. ID 管理与防冲突策略

| 方法 | 优点 | 缺点 |
| ---- | ---- | ---- |
| 手动 int | 灵活 | 容易冲突 |
| 枚举 + 生成器 | 统一来源 | 需生成脚本 |
| 外部表统一分配 | 与策划流水线对接 | 接入成本 |
| 自动分配（编辑器按钮） | 无需记忆 | 变动可能影响旧存档 |

建议：
1. 关键系统（Item / Node / Enemy）提前规划 Id 段（1000~1999 / 2000~2999）
2. 写一个编辑器工具：扫描所有 Section，输出重复 Id 列表
3. 若支持代码生成：输出一个 `ConfigIds.cs`

---

## 19. 变更记录（Changelog）

| 版本 | 内容 |
| ---- | ---- |
| 1.0 | 初始文档 |
| 1.1 | 增补资源系统拆分、运行时/存档关系、跨 Section 校验、建模指南、示例扩展 |

---

## 附录：快速 Checklist

| 需求 | 是否完成 |
| ---- | -------- |
| 新建 SectionType (继承 DefinitionSectionBase) |  |
| 添加 definitions 并填写唯一 Id |  |
| 资产加至项目（必要时放 Resources/Config/） |  |
| 运行验证日志无错误 |  |
| 使用 GetDefinition<T>(id) 成功获取 |  |
| 校验工具通过 (Validate All Sections) |  |
| 拆分物品 vs 节点定义（如涉及采集） |  |
| 运行时状态未写回 ScriptableObject |  |
|（可选）跨 Section 引用已校验 |  |
|（可选）生成 Id 常量代码 |  |
|（可选）添加自定义 Registry 查询索引 |  |

---

## 结束语

该系统核心是“模板数据静态化 + 运行时状态分离 + 可扩展加载与校验”。  
在功能尚未稳定前，不要过早引入：
- 热更新二进制格式
- 动态差分补丁
- 复杂依赖图序列

等规模与需求确立后再加。

需要：
- Id 代码生成器
- Cross Validator 模板
- Addressables 版本加载示范

请继续提出，我可以补充下一版文档或直接产出脚本。

祝开发顺利！