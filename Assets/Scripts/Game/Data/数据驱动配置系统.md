# GameContext 系统完整使用说明文档（v1.1）

## 1. 系统概述

GameContext 是游戏的核心上下文管理系统，作为数据驱动配置框架的入口点，负责统一加载、构建和管理所有游戏配置数据。该系统基于单例模式设计，通过反射机制实现配置类型的自动扫描与加载，彻底消除硬编码配置引用，支持类型安全的配置访问。

系统核心价值在于实现"**配置数据与业务逻辑的解耦**"，允许开发者通过新增配置资产而非修改代码来扩展游戏内容，特别适合需要频繁调整数值、物品、配方等数据的工厂建造类游戏（如《Asaki Factory Game》）。

## 2. 核心概念与架构

### 2.1 核心概念定义

| 概念名称 | 含义与作用 |
|---------|-----------|
| **IDefinition** | 所有配置条目的基础接口，定义唯一int类型ID |
| **IContextSection** | 配置分区标记接口，每个实现类代表一类配置集合（如物品、配方） |
| **DefinitionSectionBase<TDef>** | 泛型配置分区基类，提供配置加载与注册表构建的默认实现 |
| **DefinitionRegistry<TDef>** | 配置注册表，负责ID到配置实例的映射与查询 |
| **GameRuntimeData** | 运行时数据容器，存储所有加载后的配置分区与注册表 |
| **RuntimeConfigLoader** | 配置加载工具类，负责反射扫描配置类型并加载对应资产 |
| **GameContextConfig** | 系统配置参数，控制加载行为、日志输出等选项 |

### 2.2 系统架构图

```
┌─────────────────┐      ┌──────────────────┐      ┌───────────────────┐
│  SingletonManager  │───→│  GameContext     │───→  │  GameRuntimeData  │
└─────────────────┘      └────────┬─────────┘      └────────┬──────────┘
                                  │                         │
                   ┌──────────────┘                         │
                   ▼                                        │
        ┌─────────────────────┐                             │
        │  RuntimeConfigLoader│                             │
        └──────────┬──────────┘                             │
                   │                                        │
     ┌─────────────┴─────────────┐                          │
     ▼                           ▼                          │
┌─────────────┐           ┌─────────────┐                   │
│ 物品配置分区  │           │ 配方配置分区  │           ┌──────┴───────┐
│(ItemSection)│           │(RecipeSection)│          │  注册表集合    │
└──────┬──────┘           └──────┬──────┘           │(Registries)   │
       │                         │                   └───────────────┘
       ▼                         ▼
┌─────────────┐           ┌─────────────┐
│ 物品定义集合  │           │ 配方定义集合  │
│(ItemDefinition)│        │(RecipeDefinition)│
└─────────────┘           └─────────────┘
```

## 3. 核心组件详解

### 3.1 GameContext 类

游戏上下文核心类，继承自MonoBehaviour并实现单例初始化接口，是系统的唯一入口点。

**关键属性**：
- `Instance`：静态单例实例，通过`GameContext.Instance`访问
- `Data`：`GameRuntimeData`实例，存储所有加载的配置数据
- `config`：`GameContextConfig`引用，控制系统行为

**核心方法**：

| 方法 | 功能描述 |
|------|---------|
| `Initialize()` | 启动配置加载流程，由`SingletonManager`自动调用 |
| `TryGetRegistry<TRegistry>()` | 尝试获取指定类型的注册表（返回bool） |
| `GetRegistry<TRegistry>()` | 获取指定类型的注册表（不存在则抛异常） |
| `TryGetDefinition<TDef>()` | 尝试获取指定ID的配置定义（返回bool） |
| `GetDefinition<TDef>()` | 获取指定ID的配置定义（不存在则抛异常） |

**初始化流程**：
1. 由`SingletonManager`触发`OnRegistered`回调，设置单例实例
2. 调用`Initialize()`方法启动构建流程
3. 创建`GameRuntimeData`实例
4. 扫描所有实现`IContextSection`的类型
5. 加载对应类型的配置资产并执行`Build()`方法
6. 收集构建统计信息并输出日志

### 3.2 GameContextConfig 类

系统配置参数类，继承自`ScriptableObject`，可在编辑器中创建配置资产。

**配置项说明**：

| 配置项 | 类型 | 描述 |
|-------|------|------|
| `verbose` | bool | 是否输出详细加载日志（开发期建议开启） |
| `forceRescanOnPlay` | bool | 运行时是否强制重新扫描配置类型（关闭可提升性能） |
| `logSummaryAfterBuild` | bool | 构建完成后是否输出统计摘要 |

**使用方式**：
在Unity编辑器中右键创建：`Create → Game → GameContextConfig`，并赋值给`GameContext`预制体的`config`字段。

### 3.3 关键接口与基类

#### IContext
- 标记接口，所有需要被`GameContext`识别的配置资产必须实现此接口
- 通常与`ScriptableObject`结合使用（如`public class ItemSection : ScriptableObject, IContextSection`）

#### IContextSection
- 继承自`IContext`，定义配置分区的核心行为
- 包含`SectionName`属性（配置分区的逻辑名称）和`Build(GameRuntimeData data)`方法（构建注册表）

#### DefinitionSectionBase<TDef>
- 泛型抽象基类，实现`IContextSection`接口
- 提供默认的`SectionName`（类名）和`Build`方法实现
- 子类只需定义`List<TDef> definitions`字段即可自动构建注册表

## 4. 初始化与加载流程

### 4.1 完整执行流程

```
1. 游戏启动 → SingletonManager 初始化
2. SingletonManager 发现 GameContext 实例并调用 OnRegistered
3. GameContext 初始化单例实例 → 调用 Initialize()
4. 检查是否已构建 → 未构建则执行 BuildAll()
5. RuntimeConfigLoader 扫描所有实现 IContextSection 的类型
   - 若 forceRescanOnPlay=false，使用缓存的扫描结果
   - 若 forceRescanOnPlay=true，强制重新反射扫描
6. 对每个扫描到的类型：
   a. 加载所有对应类型的配置资产（Editor 用 AssetDatabase，运行时用 Resources）
   b. 对每个资产调用 Build() 方法，将配置数据注册到 GameRuntimeData
7. 构建完成 → 输出耗时、配置数、资产数等统计信息
8. 若启用 logSummaryAfterBuild，输出 GameRuntimeData 摘要
```

### 4.2 配置资产加载规则

| 环境 | 加载方式 | 路径要求 |
|------|---------|---------|
| 编辑器（Editor） | `AssetDatabase.FindAssets` | 无强制路径，建议放在`Assets/Configs`目录 |
| 运行时（Player） | `Resources.LoadAll("Config", sectionType)` | 必须放在`Resources/Config`目录下 |

> 注意：运行时环境下，配置资产的文件夹结构不影响加载，但必须确保最终打包到`Resources/Config`路径下。

## 5. 使用方法

### 5.1 访问配置定义

**直接获取（适用于确定存在的配置）**：
```csharp
// 获取ID为1001的物品定义
var sword = GameContext.Instance.GetDefinition<ItemDefinition>(1001);
Debug.Log($"物品名称：{sword.displayName}，伤害：{sword.damage}");

// 获取ID为3005的配方定义
var recipe = GameContext.Instance.GetDefinition<RecipeDefinition>(3005);
```

**安全获取（适用于可能不存在的配置）**：
```csharp
// 尝试获取ID为2003的采集节点定义
if (GameContext.Instance.TryGetDefinition<GatherableNodeDefinition>(2003, out var node))
{
    Debug.Log($"采集节点：{node.name}，产出：{node.dropItemId}");
}
else
{
    Debug.LogWarning("未找到ID为2003的采集节点定义");
}
```

### 5.2 操作注册表

**获取整个注册表**：
```csharp
// 获取物品注册表
var itemRegistry = GameContext.Instance.GetRegistry<ItemRegistry>();

// 枚举所有物品
foreach (var item in itemRegistry.EnumerateAll())
{
    Debug.Log($"物品ID：{item.Id}，名称：{item.name}");
}

// 按条件查询
var weapons = itemRegistry.FindAll(item => item.category == ItemCategory.Weapon);
```

**自定义注册表扩展**：
```csharp
// 自定义注册表示例
public class ItemRegistry : DefinitionRegistry<ItemDefinition>
{
    // 添加按类别查询的方法
    public List<ItemDefinition> GetByCategory(ItemCategory category)
    {
        return definitions.Where(d => d.category == category).ToList();
    }
}

// 使用自定义方法
var tools = GameContext.Instance.GetRegistry<ItemRegistry>().GetByCategory(ItemCategory.Tool);
```

### 5.3 枚举配置分区

```csharp
// 遍历所有配置分区
foreach (var (sectionName, sectionInstance) in GameContext.Instance.Data.EnumerateSections())
{
    Debug.Log($"配置分区：{sectionName}，类型：{sectionInstance.GetType().Name}");
    
    // 检查是否为物品配置分区
    if (sectionInstance is ItemSection itemSection)
    {
        Debug.Log($"该分区包含 {itemSection.definitions.Count} 个物品定义");
    }
}
```

## 6. 扩展配置系统

### 6.1 新增配置类型步骤

1. **定义配置条目类**（实现`IDefinition`）：
```csharp
public class EnemyDefinition : IDefinition
{
    public int Id { get; set; }
    public string name;
    public int health;
    public int damage;
    public float speed;
}
```

2. **创建配置分区类**（继承`DefinitionSectionBase`）：
```csharp
[CreateAssetMenu(menuName = "Game/Configs/EnemySection")]
public class EnemySection : DefinitionSectionBase<EnemyDefinition>
{
    // 可重写SectionName（默认使用类名）
    public override string SectionName => "Enemies";
    
    // 可选：重写Build方法添加自定义逻辑
    public override void Build(GameRuntimeData data)
    {
        // 执行基类的注册表构建
        base.Build(data);
        
        // 添加自定义校验逻辑
        foreach (var enemy in definitions)
        {
            if (enemy.health <= 0)
            {
                Debug.LogWarning($"敌人ID {enemy.Id} 生命值无效");
            }
        }
    }
}
```

3. **创建配置资产**：
   在Unity编辑器中右键选择`Create → Game → Configs → EnemySection`，添加敌人定义数据并保存到`Assets/Configs/Enemies`目录。

4. **使用新配置**：
```csharp
// 获取敌人定义
var slime = GameContext.Instance.GetDefinition<EnemyDefinition>(5001);
Debug.Log($"史莱姆：生命值 {slime.health}，伤害 {slime.damage}");
```

### 6.2 配置校验扩展

**实现跨分区校验**：
```csharp
public static class CrossSectionValidator
{
    public static void ValidateAll(GameRuntimeData data)
    {
        // 验证配方中引用的物品是否存在
        var recipeReg = data.Get<RecipeRegistry>();
        var itemReg = data.Get<ItemRegistry>();
        
        foreach (var recipe in recipeReg.EnumerateAll())
        {
            foreach (var ingredient in recipe.ingredients)
            {
                if (!itemReg.TryGet(ingredient.itemId, out _))
                {
                    Debug.LogError($"配方 {recipe.Id} 引用了不存在的物品 {ingredient.itemId}");
                }
            }
        }
    }
}

// 在GameContext.BuildAll()末尾调用
// CrossSectionValidator.ValidateAll(Data);
```

## 7. 编辑器工作流

### 7.1 配置管理工具

系统与`ConfigDatabaseWindow`集成，可通过`Tools/Config DB/Open Database Window`打开：
- 集中显示所有`[CustomConfig]`标记的配置资产
- 支持按类型筛选、搜索ID和名称
- 提供批量操作（如ID冲突检查、导出CSV）

### 7.2 ID常量生成

使用`ConfigIdCodeGenerator`自动生成ID常量：
1. 菜单选择`Tools/Config DB/Generate Config Id Constants`
2. 生成文件路径：`Assets/Scripts/Generated/ConfigIds.g.cs`
3. 使用示例：
```csharp
// 生成的常量类
public static partial class ConfigIds
{
    public static class ItemDefinition
    {
        public const int Wood = 1001;
        public const int Stone = 1002;
        public const int IronOre = 1003;
    }
}

// 代码中使用
var wood = GameContext.Instance.GetDefinition<ItemDefinition>(ConfigIds.ItemDefinition.Wood);
```

## 8. 性能与兼容性

### 8.1 性能优化建议

- **禁用强制扫描**：在发布版本中设置`forceRescanOnPlay=false`，减少反射开销
- **控制日志输出**：发布版本中设置`verbose=false`，避免日志IO开销
- **批量操作**：使用`EnumerateDefinitions<TDef>()`进行批量处理，而非多次调用`GetDefinition`
- **预加载**：确保`GameContext`在其他系统初始化前完成加载

### 8.2 平台兼容性

- **IL2CPP 支持**：通过类型引用和资产依赖防止代码剪裁，复杂场景可添加`link.xml`保留类型
- **资源加载**：运行时依赖`Resources`系统，确保配置资产正确打包
- **热更新支持**：如需热更新，可扩展`RuntimeConfigLoader`替换为Addressables或自定义加载器

## 9. 常见问题与解决方案

| 问题现象 | 可能原因 | 解决方案 |
|---------|---------|---------|
| `GetDefinition`抛出异常 | 对应的ID不存在或配置未加载 | 1. 检查ID是否正确<br>2. 使用`TryGetDefinition`进行安全访问<br>3. 确认配置资产放在正确目录 |
| 配置分区未加载 | 1. 未实现`IContextSection`接口<br>2. 资产未放在`Resources/Config`目录（运行时） | 1. 检查类继承关系<br>2. 验证资产路径<br>3. 开启`verbose`日志查看加载过程 |
| 出现重复ID错误 | 两个配置条目使用了相同的ID | 1. 使用`ConfigDatabaseWindow`的冲突检查功能<br>2. 运行`ConfigIdCodeGenerator`生成唯一ID |
| 运行时访问返回`null` | 访问时机早于`GameContext`初始化 | 1. 确保在`ISyncInitialize`或更晚的阶段访问<br>2. 监听`GameContext`初始化完成事件 |
| 想修改配置定义值 | 直接修改会影响所有引用 | 1. 创建运行时状态副本<br>2. 使用`Definition`作为模板，在运行时对象中存储修改 |

## 10. 版本历史

| 版本 | 变更内容 |
|-----|---------|
| 1.0 | 初始版本：基础加载与访问功能 |
| 1.1 | 1. 增加配置校验机制<br>2. 优化反射扫描性能<br>3. 完善日志系统<br>4. 新增ID常量生成工具<br>5. 支持自定义注册表扩展 |

## 11. 扩展建议

1. **热更新支持**：实现基于Addressables的`RuntimeConfigLoader`替代方案
2. **配置版本控制**：添加配置版本号，支持不同版本间的迁移逻辑
3. **动态配置**：扩展系统支持从服务器下载并合并配置
4. **可视化配置编辑**：为常用配置类型开发专用编辑窗口，替代默认Inspector
5. **配置模板系统**：实现配置继承，减少重复数据

---

系统设计遵循"**模板数据静态化、运行时状态分离、可扩展加载与校验**"的原则，建议在项目初期保持系统简洁，待需求稳定后再逐步添加复杂功能。如需进一步扩展或定制，可参考`数据驱动配置系统.md`文档中的高级指南。