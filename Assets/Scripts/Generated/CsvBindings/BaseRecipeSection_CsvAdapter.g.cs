// <auto-generated />
#nullable enable
using System;
using System.Collections.Generic;
using Game.CSV;
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif
namespace Game.Data.Definition.Recipes {
public partial class BaseRecipeSection : ICsvImportableConfig, ICsvExportableConfig, ICsvRemarkProvider
{
    public IReadOnlyList<string> GetExpectedColumns() => CsvBinding_BaseRecipeDefinition.Header;
    public IReadOnlyList<string> GetCsvHeader() => CsvBinding_BaseRecipeDefinition.Header;
    public IReadOnlyList<string> GetCsvRemarks() => CsvBinding_BaseRecipeDefinition.Remarks;
    public void PrepareForCsvImport(bool clearExisting)
    {
#if UNITY_EDITOR
        if (clearExisting) definitions.Clear();
#endif
    }
    public bool ImportCsvRow(Dictionary<string,string> row, ICsvImportHelper helper, int lineIndex)
    {
#if UNITY_EDITOR
        try
        {
            if (!row.TryGetValue("id", out var idStr) || string.IsNullOrWhiteSpace(idStr) || !int.TryParse(idStr,out var idVal))
                return false;
            BaseRecipeDefinition target = null;
            for (int i = 0; i < definitions.Count; i++)
            {
                var d = definitions[i].definition;
                if (d != null && d.Id == idVal) { target = d; break; }
            }
            if (target == null)
            {
                target = new BaseRecipeDefinition();
                definitions.Add(new DefinitionItem{ definition = target, description = ""});
            }
            CsvBinding_BaseRecipeDefinition.ImportInto(target, row, AssetCsvResolver.Instance, lineIndex);
            return true;
        }
        catch (Exception e)
        {
            helper.LogError(lineIndex, e.Message);
            return false;
        }
#else
        return false;
#endif
    }
    public void FinalizeCsvImport(int success, int error)
    {
#if UNITY_EDITOR
        definitions.Sort((a,b)=>
        {
            if (a?.definition == null || b?.definition == null) return 0;
            return a.definition.Id.CompareTo(b.definition.Id);
        });
        EditorUtility.SetDirty(this);
#endif
    }
    public IEnumerable<Dictionary<string,string>> ExportCsvRows()
    {
        foreach (var di in definitions)
        {
            if (di?.definition == null) continue;
            yield return CsvBinding_BaseRecipeDefinition.Export(di.definition);
        }
    }
    public void ExportCsv(string path, bool utf8Bom = true)
    {
        var header = CsvBinding_BaseRecipeDefinition.Header;
        var remarks = CsvBinding_BaseRecipeDefinition.Remarks;
        var rows = ExportCsvRows();
        CsvExportUtility.Write(path, header, rows, remarks, utf8Bom);
#if UNITY_EDITOR
        Debug.Log($"[CSVGen] 导出完成: {path}");
#endif
    }
    private static bool TryParsePrimitive<T>(string s, out T v)
    {
        v = default;
        if (string.IsNullOrWhiteSpace(s)) return false;
        var target = typeof(T);
        try
        {
            if (target == typeof(int))
            {
                if (int.TryParse(s, out var iv)) { v = (T)(object)iv; return true; }
                return false;
            }
            if (target == typeof(float))
            {
                if (float.TryParse(s, out var fv)) { v = (T)(object)fv; return true; }
                return false;
            }
            if (target == typeof(double))
            {
                if (double.TryParse(s, out var dv)) { v = (T)(object)dv; return true; }
                return false;
            }
            if (target == typeof(long))
            {
                if (long.TryParse(s, out var lv)) { v = (T)(object)lv; return true; }
                return false;
            }
            if (target == typeof(bool))
            {
                if (bool.TryParse(s, out var bv)) { v = (T)(object)bv; return true; }
                if (s == "1") { v = (T)(object)true; return true; }
                if (s == "0") { v = (T)(object)false; return true; }
                return false;
            }
            if (target.IsEnum)
            {
                if (Enum.TryParse(target, s, true, out var ev)) { v = (T)ev; return true; }
                return false;
            }
        }
        catch { return false; }
        return false;
    }
}
}
